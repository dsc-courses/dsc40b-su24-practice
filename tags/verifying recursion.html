<html>
    <head>
        <title>DSC 40B Practice Problems</title>
        <link rel="stylesheet" href="https://matcha.mizu.sh/matcha.css">
        <link rel="stylesheet" href="../style.css">

        <!-- MathJax -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex: {
              inlineMath: [ ['$$','$$'], ["\\(","\\)"] ],
              displayMath: [             // start/end delimiter pairs for display math
                  ['\\[', '\\]']
              ],
              processEscapes: true
            }
          });
        </script>

        <!-- highlightjs -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

        <!-- and it's easy to individually load additional languages -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

        <script>hljs.highlightAll();</script>


        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
        </script>

    </head>
    <body data-color-scheme="light">
        <div style="margin: .5em 0em; font-size: 2em;">
            <a href="..">DSC 40B Practice Problems</a>
        </div>

        
<h1>Problems tagged with "verifying recursion"</h1>


        <div class="problem-outer">
        <h2>Problem #017</h2>
        <p>Tags: <a href='../tags/verifying recursion.html'>verifying recursion</a>, <a href='../tags/binary search.html'>binary search</a></p>
        <div class="problem">
    <div class="problem-body">
<p>Suppose we modify <span class="inline-code"><code>binary_search</code></span> so that instead of using the floor operation to find the middle element of the array, we use the ceiling operation (recall that the ceiling of a real number <span class="math">\(x\)</span> is the smallest integer that is <span class="math">\(\geq x\)</span>). The full code is shown below for convenience:</p>
<pre class="code"><code>
import math

def new_binary_search(arr, start, stop, target):
    if stop <= start:
        return None

    middle = math.ceil((start + stop) / 2)

    if arr[middle] == target:
        return middle
    elif arr[middle] < target:
        return new_binary_search(arr, middle + 1, stop, target)
    else:
        return new_binary_search(arr, start, middle, target)

</code></pre>

<p>Which of the following statements about the correctness of <span class="inline-code"><code>new_binary_search</code></span> is true? You may assume that <span class="inline-code"><code>arr</code></span> will be a list containing at least one number, and that the initial call to <span class="inline-code"><code>new_binary_search</code></span> will be with <span class="inline-code"><code>start = 0</code></span> and <span class="inline-code"><code>stop
    = len(arr) - 1</code></span>.</p>
<div class="multiple-choices"><form><div class="choice"><label><input name="choice" class="choice" type="radio" /><p><span class="inline-code"><code>new_binary_search</code></span> is guaranteed to work correctly (it will find the index of the target, if the target is in the array, and return <span class="inline-code"><code>None</code></span> otherwise).</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p><span class="inline-code"><code>new_binary_search</code></span> may recurse infinitely</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p><span class="inline-code"><code>new_binary_search</code></span> may raise an <span class="inline-code"><code>IndexError</code></span> because it may attempt to access an element of the array which does not exist</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p><span class="inline-code"><code>new_binary_search</code></span> is guaranteed to return without raising an exception, but it may sometimes return the wrong answer</p></label></div></form></div>
<details>
    <summary>Solution</summary>
<p><span class="inline-code"><code>new_binary_search</code></span> may recurse infinitely</p>
</details>

    </div>
</div>

        </div>




        <div class="problem-outer">
        <h2>Problem #042</h2>
        <p>Tags: <a href='../tags/verifying recursion.html'>verifying recursion</a></p>
        <div class="problem">
    <div class="problem-body">
<p>Consider the code below which claims to compute the maximum of the input array. Adopt the convention that the maximum of an empty array is <span class="math">\(-\infty\)</span>.</p>
<pre class="code"><code>
import math
def maximum(arr, start=0, stop=None):
    """Find the maximum of arr[start:stop]."""
    if stop is None:
        stop = len(arr)
    if stop - start == 0:
        return -float('inf')

    middle = math.floor((start + stop) / 2)
    left = maximum(arr, start, middle)
    right = maximum(arr, middle, stop)
    if left > right:
        return left
    else:
        return right

</code></pre>

<p>Will this code always return the correct answer (the maximum)? If yes, simply say so. If no, describe what might happen (recurse infinitely, return the wrong answer, raise an index error, etc.).</p>
<details>
    <summary>Solution</summary>
<p>This code will recurse infinitely when called on an array with a single element.</p>
</details>

    </div>
</div>

        </div>




        <div class="problem-outer">
        <h2>Problem #069</h2>
        <p>Tags: <a href='../tags/verifying recursion.html'>verifying recursion</a>, <a href='../tags/recursion.html'>recursion</a></p>
        <div class="problem">
    <div class="problem-body">
<p>Consider the code below which claims to compute the most common element in the array, returning a pair: the element along with the number of times it appears.</p>
<pre class="code"><code>
import math

def most_common(arr, start, stop):
    """Attempts to compute the most common element in arr[start:stop]."""
    if stop - start == 1:
        return (arr[start], 1)

    middle = math.floor((start + stop) / 2)

    left_value, left_count = most_common(arr, start, middle)
    right_value, right_count = most_common(arr, middle, stop)

    if left_count > right_count:
        return (left_value, left_count)
    else:
        return (right_value, right_count)

</code></pre>

<p>You may assume that the function is always called on a non-empty array, and with <span class="inline-code"><code>start = 0</code></span> and <span class="inline-code"><code>stop = len(arr)</code></span>. Will this code always return the correct answer (the most common element)?</p>
<div class="multiple-choices"><form><div class="choice"><label><input name="choice" class="choice" type="radio" /><p>Yes: it will always return the correct answer.</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p>No: it may recurse infinitely.</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p>No: it may try to access the array at an invalid index.</p></label></div>
<div class="choice"><label><input name="choice" class="choice" type="radio" /><p>No: it will run without error, but the element returned may not be the most common element in the array.</p></label></div></form></div>
<details>
    <summary>Solution</summary>
<p>No: it will run without error, but the element returned may not be the most common element in the array.</p>
<p>It is not true in general that the most common element in the array is the most common in the left or the right. As a simple example, take: <span class="inline-code"><code>[1,1,1,0,0,2,2,2,0,0]</code></span>. 1 is the most common in the left half, and 2 is the most common in the right half, but 0 is the most common overall.</p>
<p>So even if we assume that <span class="inline-code"><code>most_common(arr, start, middle)</code></span> finds the most common element in left half of the array, and <span class="inline-code"><code>most_common(arr, middle, stop)</code></span> finds the most common element in the right of the array, it is not necessarily the case that the most common between them is the overall most common in the array.</p>
<p>You can also quickly see that the code cannot be correct because nowhere is a count greater than one ever returned.</p>
</details>

    </div>
</div>

        </div>




        <div class="problem-outer">
        <h2>Problem #083</h2>
        <p>Tags: <a href='../tags/verifying recursion.html'>verifying recursion</a>, <a href='../tags/binary search.html'>binary search</a>, <a href='../tags/recursion.html'>recursion</a></p>
        <div class="problem">
    <div class="problem-body">
<p>Suppose we modify <span class="inline-code"><code>binary_search</code></span> so that instead of using the floor operation to find the middle element of the array, we use the ceiling operation (recall that the ceiling of a real number <span class="math">\(x\)</span> is the smallest integer that is <span class="math">\(\geq x\)</span>). The full code is shown below for convenience:</p>
<pre class="code"><code>
import math

def new_binary_search(arr, start, stop, target):
    if stop <= start:
        return None

    middle = math.ceil((start + stop) / 2)

    if arr[middle] == target:
        return middle
    elif arr[middle] < target:
        return new_binary_search(arr, middle + 1, stop, target)
    else:
        return new_binary_search(arr, start, middle, target)

</code></pre>

<p>You may assume that <span class="inline-code"><code>arr</code></span> will be a sorted list containing at least one number, and that the initial call to <span class="inline-code"><code>new_binary_search</code></span> will be with <span class="inline-code"><code>start = 0</code></span> and <span class="inline-code"><code>stop = len(arr)</code></span>.</p>
<div class="subproblem">
    <h3 class="subproblem-id">Part 1)</h3>
<p>True or False: there are input arrays on which <span class="inline-code"><code>new_binary_search</code></span> will recurse infinitely.</p>

<div class="true-false">
    <input type="radio" name="true-false" value="true" /> True
    <input type="radio" name="true-false" value="false" /> False
</div>

<details>
    <summary>Solution</summary>
<p>True.</p>
</details>

</div>

<div class="subproblem">
    <h3 class="subproblem-id">Part 2)</h3>
<p>True or False: there are input arrays on which <span class="inline-code"><code>new_binary_search</code></span> will raise an <span class="inline-code"><code>IndexError</code></span> because it attempts to access an element of the array which does not exist.</p>

<div class="true-false">
    <input type="radio" name="true-false" value="true" /> True
    <input type="radio" name="true-false" value="false" /> False
</div>

<details>
    <summary>Solution</summary>
<p>True.</p>
</details>

</div>

    </div>
</div>

        </div>



    </body>
</html>
